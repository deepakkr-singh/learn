# ============================================================================
# VARIABLES FOR CREATING DYNAMODB TABLES
# ============================================================================
#
# INSTRUCTIONS:
# 1. Copy this file to variables.tf
# 2. Customize default values as needed
# 3. Set values in terraform.tfvars
#
# ============================================================================

# ----------------------------------------------------------------------------
# REQUIRED VARIABLES
# ----------------------------------------------------------------------------

variable "project_name" {
  description = "Project name for resource naming"
  type        = string
  default     = "myproject"
}

variable "environment" {
  description = "Environment (dev, staging, prod)"
  type        = string
  default     = "dev"

  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod"
  }
}

variable "table_purpose" {
  description = "What is this table for? (e.g., users, orders, sessions)"
  type        = string
  default     = "general"
}

# ----------------------------------------------------------------------------
# TABLE CONFIGURATION
# ----------------------------------------------------------------------------

variable "create_table" {
  description = "Set to true to create DynamoDB table"
  type        = bool
  default     = true
}

variable "table_name" {
  description = "Name of the DynamoDB table"
  type        = string
  default     = ""

  # If empty, auto-generated: projectname-environment-purpose
  # Example: myapp-prod-users
}

variable "billing_mode" {
  description = "Billing mode (PAY_PER_REQUEST or PROVISIONED)"
  type        = string
  default     = "PAY_PER_REQUEST"

  validation {
    condition     = contains(["PAY_PER_REQUEST", "PROVISIONED"], var.billing_mode)
    error_message = "Billing mode must be PAY_PER_REQUEST or PROVISIONED"
  }

  # PAY_PER_REQUEST = On-demand (pay per request, auto-scaling)
  # PROVISIONED     = Pre-provisioned capacity (cheaper if predictable)
}

variable "table_class" {
  description = "Table class (STANDARD or STANDARD_INFREQUENT_ACCESS)"
  type        = string
  default     = "STANDARD"

  validation {
    condition     = contains(["STANDARD", "STANDARD_INFREQUENT_ACCESS"], var.table_class)
    error_message = "Table class must be STANDARD or STANDARD_INFREQUENT_ACCESS"
  }

  # STANDARD                    = Normal table (default)
  # STANDARD_INFREQUENT_ACCESS  = 50% cheaper storage, for rarely accessed data
}

variable "deletion_protection_enabled" {
  description = "Enable deletion protection?"
  type        = bool
  default     = false

  # true  = Cannot delete table without disabling protection first
  # false = Can delete table anytime
}

# ----------------------------------------------------------------------------
# PRIMARY KEY
# ----------------------------------------------------------------------------

variable "partition_key_name" {
  description = "Partition key (hash key) name"
  type        = string
  default     = "id"

  # Examples: user_id, order_id, session_id
  # This is the primary unique identifier
}

variable "partition_key_type" {
  description = "Partition key type (S=String, N=Number, B=Binary)"
  type        = string
  default     = "S"

  validation {
    condition     = contains(["S", "N", "B"], var.partition_key_type)
    error_message = "Partition key type must be S, N, or B"
  }
}

variable "sort_key_name" {
  description = "Sort key (range key) name (leave empty if not needed)"
  type        = string
  default     = ""

  # Examples: timestamp, order_date, created_at
  # Optional: Only if you need to sort items within same partition key
}

variable "sort_key_type" {
  description = "Sort key type (S=String, N=Number, B=Binary)"
  type        = string
  default     = "S"

  validation {
    condition     = contains(["S", "N", "B"], var.sort_key_type)
    error_message = "Sort key type must be S, N, or B"
  }
}

# ----------------------------------------------------------------------------
# PROVISIONED CAPACITY (Only if billing_mode = PROVISIONED)
# ----------------------------------------------------------------------------

variable "read_capacity" {
  description = "Read capacity units (only for PROVISIONED mode)"
  type        = number
  default     = 5

  # 1 RCU = 1 strongly consistent read/sec (up to 4 KB)
  #       = 2 eventually consistent reads/sec (up to 4 KB)
}

variable "write_capacity" {
  description = "Write capacity units (only for PROVISIONED mode)"
  type        = number
  default     = 5

  # 1 WCU = 1 write/sec (up to 1 KB)
}

# ----------------------------------------------------------------------------
# AUTO-SCALING (Only for PROVISIONED mode)
# ----------------------------------------------------------------------------

variable "enable_autoscaling" {
  description = "Enable auto-scaling for provisioned capacity?"
  type        = bool
  default     = false

  # Only applicable if billing_mode = PROVISIONED
}

variable "autoscaling_read_target" {
  description = "Target utilization for read capacity (0-100)"
  type        = number
  default     = 70

  # Auto-scaling triggers when utilization exceeds this percentage
}

variable "autoscaling_read_max_capacity" {
  description = "Maximum read capacity units for auto-scaling"
  type        = number
  default     = 100
}

variable "autoscaling_write_target" {
  description = "Target utilization for write capacity (0-100)"
  type        = number
  default     = 70
}

variable "autoscaling_write_max_capacity" {
  description = "Maximum write capacity units for auto-scaling"
  type        = number
  default     = 100
}

# ----------------------------------------------------------------------------
# GLOBAL SECONDARY INDEXES (GSI)
# ----------------------------------------------------------------------------

variable "global_secondary_indexes" {
  description = "List of Global Secondary Indexes"
  type = list(object({
    name               = string
    hash_key           = string
    range_key          = optional(string)
    projection_type    = string
    non_key_attributes = optional(list(string))
    read_capacity      = optional(number)
    write_capacity     = optional(number)
  }))
  default = []

  # Example:
  # [{
  #   name            = "EmailIndex"
  #   hash_key        = "email"
  #   projection_type = "ALL"
  # }]
}

variable "additional_attributes" {
  description = "Additional attributes for GSI/LSI (beyond partition and sort keys)"
  type = list(object({
    name = string
    type = string
  }))
  default = []

  # Example:
  # [{name = "email", type = "S"}]
}

# ----------------------------------------------------------------------------
# LOCAL SECONDARY INDEXES (LSI)
# ----------------------------------------------------------------------------

variable "local_secondary_indexes" {
  description = "List of Local Secondary Indexes"
  type = list(object({
    name               = string
    range_key          = string
    projection_type    = string
    non_key_attributes = optional(list(string))
  }))
  default = []

  # LSI shares same partition key, but different sort key
}

# ----------------------------------------------------------------------------
# STREAMS
# ----------------------------------------------------------------------------

variable "stream_enabled" {
  description = "Enable DynamoDB Streams?"
  type        = bool
  default     = false

  # Streams capture all changes (insert, update, delete)
  # Used to trigger Lambda functions
}

variable "stream_view_type" {
  description = "Stream view type"
  type        = string
  default     = "NEW_AND_OLD_IMAGES"

  validation {
    condition = contains([
      "KEYS_ONLY",
      "NEW_IMAGE",
      "OLD_IMAGE",
      "NEW_AND_OLD_IMAGES"
    ], var.stream_view_type)
    error_message = "Invalid stream view type"
  }

  # KEYS_ONLY          = Only key attributes
  # NEW_IMAGE          = Entire item after modification
  # OLD_IMAGE          = Entire item before modification
  # NEW_AND_OLD_IMAGES = Both old and new images
}

# ----------------------------------------------------------------------------
# TTL (Time To Live)
# ----------------------------------------------------------------------------

variable "ttl_enabled" {
  description = "Enable TTL (Time To Live)?"
  type        = bool
  default     = false

  # Automatically delete expired items
}

variable "ttl_attribute_name" {
  description = "Attribute name for TTL (must be a Number in epoch seconds)"
  type        = string
  default     = "expires_at"

  # Item will be deleted when current time > expires_at value
}

# ----------------------------------------------------------------------------
# BACKUP AND RECOVERY
# ----------------------------------------------------------------------------

variable "point_in_time_recovery_enabled" {
  description = "Enable point-in-time recovery?"
  type        = bool
  default     = false

  # true  = Can restore table to any point in last 35 days (costs extra)
  # false = No continuous backups (free)
}

# ----------------------------------------------------------------------------
# ENCRYPTION
# ----------------------------------------------------------------------------

variable "kms_key_id" {
  description = "KMS key ARN for encryption (leave empty for AWS managed key)"
  type        = string
  default     = ""

  # Empty = AWS managed key (free, no access control)
  # Provide KMS key = Customer managed key (more control, costs extra)
}

# ----------------------------------------------------------------------------
# GLOBAL TABLES (Multi-Region Replication)
# ----------------------------------------------------------------------------

variable "replica_regions" {
  description = "List of regions for global table replicas"
  type        = list(string)
  default     = []

  # Example: ["us-west-2", "eu-west-1"]
  # Creates multi-region replicated table
}

variable "replica_kms_keys" {
  description = "Map of region to KMS key ARN for replica encryption"
  type        = map(string)
  default     = {}

  # Example: {"us-west-2" = "arn:aws:kms:us-west-2:..."}
}

# ----------------------------------------------------------------------------
# TAGS
# ----------------------------------------------------------------------------

variable "common_tags" {
  description = "Common tags to apply to all resources"
  type        = map(string)
  default = {
    ManagedBy = "Terraform"
    Module    = "dynamodb"
  }
}

# ----------------------------------------------------------------------------
# EXAMPLE terraform.tfvars
# ----------------------------------------------------------------------------
/*

# Configuration 1: Simple Key-Value Store (User Sessions)
# --------------------------------------------------------
# Cost: Nearly free (first 25 GB storage free)

project_name  = "myapp"
environment   = "prod"
table_purpose = "sessions"

# This creates table: myapp-prod-sessions

partition_key_name = "session_id"
partition_key_type = "S"
sort_key_name      = ""  # No sort key needed

billing_mode = "PAY_PER_REQUEST"  # On-demand (auto-scaling)

# TTL for auto-expiring sessions
ttl_enabled        = true
ttl_attribute_name = "expires_at"

# No GSI needed for simple lookups
global_secondary_indexes = []

# Basic security
point_in_time_recovery_enabled = false
kms_key_id                     = ""  # AWS managed key

common_tags = {
  Project   = "MyApp"
  Team      = "Engineering"
  ManagedBy = "Terraform"
}


# Configuration 2: One-to-Many (User Orders)
# -------------------------------------------
# Cost: ~$2-5/month for 1M reads

project_name  = "ecommerce"
environment   = "prod"
table_purpose = "orders"

partition_key_name = "user_id"
partition_key_type = "S"
sort_key_name      = "order_date"  # Sort orders by date
sort_key_type      = "S"

billing_mode = "PAY_PER_REQUEST"

# No TTL (keep orders forever)
ttl_enabled = false

# Encryption for sensitive data
kms_key_id                     = "arn:aws:kms:us-east-1:123456789012:key/..."
point_in_time_recovery_enabled = true  # Enable backups

common_tags = {
  Project    = "E-commerce"
  CostCenter = "Product"
  ManagedBy  = "Terraform"
}


# Configuration 3: GSI for Alternate Queries (Users Table)
# ---------------------------------------------------------
# Cost: ~$3-8/month (includes GSI costs)

project_name  = "socialapp"
environment   = "prod"
table_purpose = "users"

partition_key_name = "user_id"
partition_key_type = "S"
sort_key_name      = ""

billing_mode = "PAY_PER_REQUEST"

# Additional attributes for GSI
additional_attributes = [
  { name = "email", type = "S" }
]

# GSI to query by email
global_secondary_indexes = [
  {
    name            = "EmailIndex"
    hash_key        = "email"
    projection_type = "ALL"
  }
]

# Streams to trigger Lambda on user changes
stream_enabled   = true
stream_view_type = "NEW_AND_OLD_IMAGES"

point_in_time_recovery_enabled = true
kms_key_id                     = "arn:aws:kms:..."

common_tags = {
  Project   = "Social App"
  Team      = "Backend"
  ManagedBy = "Terraform"
}


# Configuration 4: Provisioned Capacity (Predictable Traffic)
# ------------------------------------------------------------
# Cost: ~$2-10/month (cheaper than on-demand if traffic constant)

project_name  = "fintech"
environment   = "prod"
table_purpose = "transactions"

partition_key_name = "transaction_id"
partition_key_type = "S"
sort_key_name      = "timestamp"
sort_key_type      = "N"

billing_mode   = "PROVISIONED"
read_capacity  = 10  # 10 reads/sec
write_capacity = 5   # 5 writes/sec

# Auto-scaling for traffic spikes
enable_autoscaling             = true
autoscaling_read_target        = 70
autoscaling_read_max_capacity  = 100
autoscaling_write_target       = 70
autoscaling_write_max_capacity = 50

# Streams for audit trail
stream_enabled   = true
stream_view_type = "NEW_AND_OLD_IMAGES"

# Max security
deletion_protection_enabled    = true
point_in_time_recovery_enabled = true
kms_key_id                     = "arn:aws:kms:..."

common_tags = {
  Project     = "FinTech Platform"
  Compliance  = "SOC2"
  Environment = "Production"
  ManagedBy   = "Terraform"
}

*/

# ----------------------------------------------------------------------------
# DECISION GUIDE: ON-DEMAND VS PROVISIONED CAPACITY
# ----------------------------------------------------------------------------
/*

Question: Should I use On-Demand (PAY_PER_REQUEST) or Provisioned capacity?

On-Demand (PAY_PER_REQUEST) - RECOMMENDED FOR MOST:
---------------------------------------------------
✅ Use when:
- Traffic is unpredictable or variable
- New application (don't know traffic patterns yet)
- Development/staging environments
- Spiky workloads (weekend traffic, event-driven)
- Small to medium traffic

Pros:
✅ No capacity planning needed
✅ Automatic scaling
✅ Pay only for what you use
✅ No throttling

Cons:
⚠️ More expensive per request (if traffic is constant and high)

Cost:
- Reads: $1.25 per million
- Writes: $6.25 per million

Examples:
- 100K reads/month: $0.125
- 1M reads/month: $1.25
- 10M reads/month: $12.50


Provisioned Capacity (PROVISIONED):
-----------------------------------
✅ Use when:
- Traffic is predictable and constant
- Very high traffic (cheaper at scale)
- Can forecast capacity needs
- Production with stable load

Pros:
✅ Cheaper per request (if using most capacity)
✅ Can use auto-scaling

Cons:
❌ Must plan capacity upfront
❌ Pay for idle capacity
❌ Throttling if exceeded
❌ More complex to manage

Cost:
- $0.47/month per RCU (10 reads/sec)
- $2.35/month per WCU (10 writes/sec)

Example (constant 10 reads/sec):
- On-demand: ~$32/month
- Provisioned: ~$0.47/month
- Savings: 98%!

IMPORTANT: For most beginners, start with On-Demand!

*/

# ----------------------------------------------------------------------------
# COST ESTIMATION GUIDE
# ----------------------------------------------------------------------------
/*

DynamoDB Pricing:
-----------------

Storage:
- First 25 GB: FREE
- After: $0.25/GB/month
- Infrequent Access table class: $0.10/GB/month (60% savings)

On-Demand Requests:
- Reads: $1.25 per million reads
- Writes: $6.25 per million writes

Provisioned Capacity:
- Read: $0.47/month per RCU (10 reads/sec)
- Write: $2.35/month per WCU (10 writes/sec)

Streams:
- $0.02 per 100K read requests

Backups:
- Point-in-time recovery: $0.20/GB/month
- On-demand backups: $0.10/GB

Global Tables:
- Replicated write: $9.375 per million writes (1.5x normal cost)

Examples:
---------

Small App (sessions table, 100K reads, 10K writes/month):
- Storage: FREE (under 25 GB)
- Reads: $0.125
- Writes: $0.0625
Total: $0.19/month (essentially FREE!)

Medium App (users table, 1M reads, 100K writes/month):
- Storage: $0.25 (1 GB)
- Reads: $1.25
- Writes: $0.625
Total: $2.13/month

Large App (orders table, 10M reads, 1M writes/month):
- Storage: $2.50 (10 GB)
- Reads: $12.50
- Writes: $6.25
- Point-in-time recovery: $2.00
Total: $23.25/month

Very Large App (100M reads, 10M writes/month):
- Storage: $25 (100 GB)
- Reads: $125
- Writes: $62.50
- GSI (2 indexes): +40% = $75
Total: $287.50/month

*/
